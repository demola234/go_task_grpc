// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: tasks.sql

package db

import (
	"context"
	"time"
)

const createTasks = `-- name: CreateTasks :one
INSERT INTO
    tasks (
        task_name, created_at, task_description, due_date, task_status
    )
VALUES ($1, $2, $3, $4, $5) RETURNING id, task_name, task_description, created_at, due_date, task_status
`

type CreateTasksParams struct {
	TaskName        string    `json:"task_name"`
	CreatedAt       time.Time `json:"created_at"`
	TaskDescription string    `json:"task_description"`
	DueDate         time.Time `json:"due_date"`
	TaskStatus      string    `json:"task_status"`
}

func (q *Queries) CreateTasks(ctx context.Context, arg CreateTasksParams) (Tasks, error) {
	row := q.db.QueryRowContext(ctx, createTasks,
		arg.TaskName,
		arg.CreatedAt,
		arg.TaskDescription,
		arg.DueDate,
		arg.TaskStatus,
	)
	var i Tasks
	err := row.Scan(
		&i.ID,
		&i.TaskName,
		&i.TaskDescription,
		&i.CreatedAt,
		&i.DueDate,
		&i.TaskStatus,
	)
	return i, err
}

const deleteTasks = `-- name: DeleteTasks :exec
DELETE FROM tasks WHERE id = $1
`

func (q *Queries) DeleteTasks(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTasks, id)
	return err
}

const getTask = `-- name: GetTask :one
SELECT id, task_name, task_description, created_at, due_date, task_status FROM tasks WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTask(ctx context.Context, id int64) (Tasks, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i Tasks
	err := row.Scan(
		&i.ID,
		&i.TaskName,
		&i.TaskDescription,
		&i.CreatedAt,
		&i.DueDate,
		&i.TaskStatus,
	)
	return i, err
}

const listTasks = `-- name: ListTasks :many
SELECT id, task_name, task_description, created_at, due_date, task_status FROM tasks 
ORDER BY id
`

func (q *Queries) ListTasks(ctx context.Context) ([]Tasks, error) {
	rows, err := q.db.QueryContext(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tasks
	for rows.Next() {
		var i Tasks
		if err := rows.Scan(
			&i.ID,
			&i.TaskName,
			&i.TaskDescription,
			&i.CreatedAt,
			&i.DueDate,
			&i.TaskStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByCategory = `-- name: ListTasksByCategory :many
SELECT id, task_name, task_description, created_at, due_date, task_status
FROM tasks
WHERE
    task_status = $1
ORDER BY id
LIMIT $2
OFFSET $3
`

type ListTasksByCategoryParams struct {
	TaskStatus string `json:"task_status"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListTasksByCategory(ctx context.Context, arg ListTasksByCategoryParams) ([]Tasks, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByCategory, arg.TaskStatus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tasks
	for rows.Next() {
		var i Tasks
		if err := rows.Scan(
			&i.ID,
			&i.TaskName,
			&i.TaskDescription,
			&i.CreatedAt,
			&i.DueDate,
			&i.TaskStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTasks = `-- name: UpdateTasks :exec
UPDATE tasks
SET
    task_name = $2,
    due_date = $3,
    task_status = $4
WHERE
    id = $1 RETURNING id, task_name, task_description, created_at, due_date, task_status
`

type UpdateTasksParams struct {
	ID         int64     `json:"id"`
	TaskName   string    `json:"task_name"`
	DueDate    time.Time `json:"due_date"`
	TaskStatus string    `json:"task_status"`
}

func (q *Queries) UpdateTasks(ctx context.Context, arg UpdateTasksParams) error {
	_, err := q.db.ExecContext(ctx, updateTasks,
		arg.ID,
		arg.TaskName,
		arg.DueDate,
		arg.TaskStatus,
	)
	return err
}
